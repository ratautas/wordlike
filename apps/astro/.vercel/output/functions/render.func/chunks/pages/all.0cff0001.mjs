/* empty css                               */import { c as createAstro, a as createComponent, r as renderTemplate, m as maybeRenderHead, b as addAttribute, d as renderComponent, e as renderHead, f as renderSlot } from '../astro.54b5cdbb.mjs';
import { createClient } from '@supabase/supabase-js';

function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs#run-time-svelte-ondestroy
 */
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
 */
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
Promise.resolve();
const ATTR_REGEX = /[&"]/g;
const CONTENT_REGEX = /[&<]/g;
/**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 */
function escape(value, is_attr = false) {
    const str = String(value);
    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
    pattern.lastIndex = 0;
    let escaped = '';
    let last = 0;
    while (pattern.test(str)) {
        const i = pattern.lastIndex - 1;
        const ch = str[i];
        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '"' ? '&quot;' : '&lt;'));
        last = i + 1;
    }
    return escaped + str.substring(last);
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots, context) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(context || (parent_component ? parent_component.$$.context : [])),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
            on_destroy = [];
            const result = { title: '', head: '', css: new Set() };
            const html = $$render(result, props, {}, $$slots, context);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.title + result.head
            };
        },
        $$render
    };
}
function add_attribute(name, value, boolean) {
    if (value == null || (boolean && !value))
        return '';
    const assignment = (boolean && value === true) ? '' : `="${escape(value, true)}"`;
    return ` ${name}${assignment}`;
}

/* Users/algirdastamasauskas/wordlike/packages/nebula/package/elements/Text.svelte generated by Svelte v3.55.1 */

const css = {
	code: ".text.svelte-1tgc0nl{overflow-wrap:break-word}.text.svelte-1tgc0nl h1{font-size:2rem;font-weight:700}.text.svelte-1tgc0nl h2{font-size:1.5rem;font-weight:700}.text.svelte-1tgc0nl h3{font-size:1.3rem;font-weight:700}.text.svelte-1tgc0nl h4{font-size:1rem;font-weight:700}.text.svelte-1tgc0nl ul{list-style:disc;padding-left:1.5rem}.text.svelte-1tgc0nl ol{list-style:decimal;padding-left:1.5rem}.text.svelte-1tgc0nl li{margin-bottom:0.5rem}",
	map: null
};

const Text = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	const dispatch = createEventDispatcher();
	let { elementData } = $$props;
	let elementRef;
	onDestroy(() => dispatch("destroy"));
	if ($$props.elementData === void 0 && $$bindings.elementData && elementData !== void 0) $$bindings.elementData(elementData);
	$$result.css.add(css);

	return `<div class="${"text svelte-1tgc0nl"}"${add_attribute("this", elementRef, 0)}><!-- HTML_TAG_START -->${elementData?.html}<!-- HTML_TAG_END -->
</div>`;
});

const DEVICE_KEYS = {
    DESKTOP: 'desktop',
    // TABLET: 'tablet',
    MOBILE: 'mobile',
};
const DEVICE_DEFAULTS = {
    desktop: {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        paddingX: 24,
        paddingY: 24,
    },
    tablet: {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        paddingX: 24,
        paddingY: 24,
    },
    mobile: {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        paddingX: 24,
        paddingY: 24,
    },
};

function calculateGrid({ elementData, deviceKey }) {
    if (!elementData)
        return {};
    const { rows, columns, positions } = elementData
        .children?.reduce((acc, element) => {
        const { x, y, width, height, snapLeft, snapRight } = element[deviceKey] ?? DEVICE_DEFAULTS[deviceKey];
        acc.columns.add(x);
        acc.columns.add(x + width);
        acc.rows.add(y);
        acc.rows.add(y + height);
        acc.positions.push({ x, y, width, height, snapLeft, snapRight });
        return acc;
    }, {
        rows: new Set([0]),
        columns: new Set([0, elementData[deviceKey]?.width ?? DEVICE_DEFAULTS[deviceKey].width]),
        positions: [],
    });
    const gridRows = [...rows].sort((a, b) => a - b);
    const gridColumns = [...columns].sort((a, b) => a - b);
    const gridHeight = gridRows[gridRows.length - 1];
    const gridAreas = positions.map((position) => {
        const { x, y, width, height, snapLeft, snapRight } = position;
        const rowStartIndex = gridRows.indexOf(y) + 2;
        const rowEndIndex = gridRows.indexOf(y + height) + 2;
        const columnCount = gridColumns.length;
        const columnStartIndex = snapLeft ? 1 : gridColumns.indexOf(x) + 2;
        const columnEndIndex = snapRight ? columnCount + 2 : gridColumns.indexOf(x + width) + 2;
        return [rowStartIndex, columnStartIndex, rowEndIndex, columnEndIndex].join("/");
    });
    const { gridTemplateRows } = gridRows
        .filter((i) => i > 0)
        .reduce((acc, row) => {
        const currentRow = row - acc.previousRow;
        return {
            gridTemplateRows: [...acc.gridTemplateRows, currentRow],
            previousRow: acc.previousRow + currentRow,
        };
    }, {
        gridTemplateRows: [],
        previousRow: 0,
    });
    const { gridTemplateColumns } = gridColumns
        .filter((i) => i > 0)
        .reduce((acc, column) => {
        const currentColumn = column - acc.previousColumn;
        return {
            gridTemplateColumns: [...acc.gridTemplateColumns, currentColumn],
            previousColumn: acc.previousColumn + currentColumn,
        };
    }, {
        gridTemplateColumns: [],
        previousColumn: 0,
    });
    return { gridAreas, gridHeight, gridTemplateRows, gridTemplateColumns };
}

function getTemplateRows({ elementData, gridTemplateRows, deviceKey }) {
    return [
        elementData[deviceKey]?.paddingY ?? DEVICE_DEFAULTS[deviceKey].paddingY,
        ...gridTemplateRows,
        elementData[deviceKey]?.paddingY ?? DEVICE_DEFAULTS[deviceKey].paddingY
    ]
        .map((row) => `minmax(${row}px, 0fr)`)
        .join(' ');
}

function getTemplateColumns({ elementData, gridTemplateColumns, deviceKey }) {
    const paddingX = elementData[deviceKey]?.paddingX ?? DEVICE_DEFAULTS[deviceKey].paddingX;
    const width = elementData[deviceKey]?.width ?? DEVICE_DEFAULTS[deviceKey].width;
    return [
        `minmax(${paddingX ?? 0}px, calc(50% - ${width / 2}px))`,
        ...gridTemplateColumns,
        `minmax(${paddingX ?? 0}px, calc(50% - ${width / 2}px))`
    ]
        .map((col) => {
        if (isNaN(Number(col)))
            return col;
        // return `${Math.round(col as number / width * 1000)}fr`;
        return `${col / width * 1000}fr`;
    })
        .join(' ');
}

function getGridVars(elementData) {
    return Object.values(DEVICE_KEYS).reduce((acc, deviceKey) => {
        const { gridTemplateRows, gridTemplateColumns, gridAreas } = calculateGrid({
            elementData,
            deviceKey,
        });
        const templateRows = getTemplateRows({
            elementData,
            gridTemplateRows,
            deviceKey,
        });
        const templateColumns = getTemplateColumns({
            elementData,
            gridTemplateColumns,
            deviceKey,
        });
        acc.gridCssVars += `--${deviceKey}-rows: ${templateRows}; --${deviceKey}-columns: ${templateColumns};`;
        gridAreas?.forEach((area, index) => {
            acc.elementCssVars[index] ??= '';
            acc.elementCssVars[index] += `--${deviceKey}-area: ${area};`;
        });
        return acc;
    }, {
        gridCssVars: '',
        elementCssVars: []
    });
}

const $$Astro$2 = createAstro();
const $$AstroElement = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$2, $$props, $$slots);
  Astro2.self = $$AstroElement;
  const { elementData } = Astro2.props;
  const { children, type } = elementData ?? {};
  const { gridCssVars, elementCssVars } = type === "GRID" && getGridVars(elementData);
  return renderTemplate`${type === "GRID" && renderTemplate`${maybeRenderHead($$result)}<div class="plane"${addAttribute(gridCssVars, "style")}>
            ${children.map((child, i) => renderTemplate`<div class="element"${addAttribute(elementCssVars[i], "style")}>
                    ${renderComponent($$result, "Astro.self", Astro2.self, { "elementData": child })}
                </div>`)}
        </div>`}

${type === "TEXT" && renderTemplate`${renderComponent($$result, "Text", Text, { "elementData": elementData })}`}`;
}, "/Users/algirdastamasauskas/wordlike/apps/astro/src/components/AstroElement.astro");

const $$Astro$1 = createAstro();
const $$Layout = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);
  Astro2.self = $$Layout;
  const { title } = Astro2.props;
  return renderTemplate`<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width">
		<link rel="icon" type="image/svg+xml" href="/favicon.svg">
		<meta name="generator"${addAttribute(Astro2.generator, "content")}>
		<title>${title}</title>
	${renderHead($$result)}</head>
	<body>
		${renderSlot($$result, $$slots["default"])}
	</body></html>`;
}, "/Users/algirdastamasauskas/wordlike/apps/astro/src/layouts/Layout.astro");

const $$Astro = createAstro();
const $$ = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$;
  const supabaseClient = createClient(
    "https://cyogxqmbvjuaordoqncy.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN5b2d4cW1idmp1YW9yZG9xbmN5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE2NzMxNTgwNDQsImV4cCI6MTk4ODczNDA0NH0.sMaD75y8vo6TFfBUdbcjp2M_sknnu9BqwKbMlEnioto"
  );
  const { params, url, redirect } = Astro2;
  const { slug } = params;
  const siteId = url.hostname.split(".")[0];
  const { data, error } = await supabaseClient.from("sites").select().eq("id", siteId).single();
  const { pages } = data.doc;
  const page = pages.find((page2) => page2.isHome || page2.slug === slug);
  if (!page)
    return redirect("/404");
  return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": "Welcome to Astro." }, { "default": () => renderTemplate`${maybeRenderHead($$result)}<main>
    ${page.children.map((elementData) => renderTemplate`${renderComponent($$result, "AstroElement", $$AstroElement, { "elementData": elementData })}`)}
  </main>` })}`;
}, "/Users/algirdastamasauskas/wordlike/apps/astro/src/pages/[...slug].astro");

const $$file = "/Users/algirdastamasauskas/wordlike/apps/astro/src/pages/[...slug].astro";
const $$url = "/[...slug]";

const _page0 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: $$,
    file: $$file,
    url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page0 as _ };
